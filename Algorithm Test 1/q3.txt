boolean minProduct(int[] A)
    N = length(A)
    minProduct = INFINITY
    for i from 0 to (N - 2)
        for j from (i + 1) to (N - 1)
            if (A[i] * A[j] < minProduct)
                minProduct = A[i] * A[j]
    return minProduct

The curly braces state the execution times of respective statement on the left side:

boolean minProduct(int[] A)
    N = length(A)                                       {1}
    minProduct = INFINITY                               {1}
    for i from 0 to (N - 2)                             {N-1}
        for j from (i + 1) to (N - 1)                   {multiply(N - i - 1) for i from 0 to N - 2}
            if (A[i] * A[j] < minProduct)               {multiply(N - i - 1) for i from 0 to N - 2}
                minProduct = A[i] * A[j]                {1}
    return minProduct                                   {1}

The statement with the largest number of execution time is the nested for loop inside

multiply(N - i - 1) for i from 0 to N - 2

i = 0 => the element is N - 2
i = 1 => the element is N - 1
....
i = (N - 2) => the element is 1

So the multiply is: 1 + 2 + .... + (N - 1) + (N - 2) = N * (N - 2) / 2
=> Time Complexity = O(N ^ 2)


--------------------------------------------------------------------------

Since A is sorted 
we can declare two pointers at beginning and rear of the array
    int start = A[0]
    minProduct = INFINITY
    int end = A[length(A) - 1]
    for i from 0 to N - 1
        if (A[start] * A[end] < minProduct) {
            minProduct = A[start] * A[end];
            start++;
        }
        else if (A[start] * A[end] > minProduct){
            end--;
        }
        else {
            continue;
        }
    return minProduct

Since there is one for loop in the implementation, the time Complexity is O(n);